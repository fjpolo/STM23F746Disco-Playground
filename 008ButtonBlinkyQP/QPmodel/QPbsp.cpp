//.$file${.::QPmodel::QPbsp.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: blinkyQPmodel.qm
// File:  ${.::QPmodel::QPbsp.cpp}
//
// This code has been generated by QM 5.1.1 <www.state-machine.com/qm/>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//
//.$endhead${.::QPmodel::QPbsp.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//.$file${.::QPmodel::QPbsp.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: blinkyQPmodel.qm
// File:  ${.::QPmodel::QPbsp.cpp}
//
// This code has been generated by QM 5.1.1 <www.state-machine.com/qm/>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//
//.$endhead${.::QPmodel::QPbsp.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "qpcpp.hpp"  // QP/C++ framework API
#include "QPbsp.hpp"    // Board Support Package interface
#include <iostream>   // for cout/cerr
#include <cstdlib>    // for exit()
#include "bsp.h"


using namespace std;
using namespace QP;

static BSP::MainData_t MainData;

// ISRs used in this project =================================================
extern "C" {

//............................................................................
void SysTick_Handler(void); // prototype
void SysTick_Handler(void) {
    QK_ISR_ENTRY();   // inform QK about entering an ISR
    QF::TICK_X(0U, nullptr); // process time events for rate 0
    HAL_IncTick();
    QK_ISR_EXIT();  // inform QK about exiting an ISR
}

} // extern "C"

void QPBSP::init(void)   {
    BSP::Init(&MainData);
    //BSP::debug("\rHello World\r\n");
}
void QPBSP::ledOff(void) {
    MainData.userLED->setPinLow();

}
void QPBSP::ledOn(void)  {
    MainData.userLED->setPinHigh();
}
    void QPBSP::readButton(void){
    static BSP::GPIOPinState pinState{BSP::GPIOPinState::PinLow}, lastPinState{BSP::GPIOPinState::PinLow};
    pinState = MainData.userButton->readPin();
    if( (pinState == BSP::GPIOPinState::PinHigh) && (pinState != lastPinState) ){
        QP::QEvt evt;
        evt.sig = BUTTON_PRESSED_SIG;
        AO_Blinky->post_(&evt, QP::QF_NO_MARGIN);
    }
    else if(pinState != lastPinState){
        QP::QEvt evt;
        evt.sig = BUTTON_RELEASED_SIG;
        AO_Blinky->post_(&evt, QP::QF_NO_MARGIN);
    }
    lastPinState = pinState;
}

// callback functions needed by the framework --------------------------------
void QF::onStartup(void) {
    // set up the SysTick timer to fire at BSP::TICKS_PER_SEC rate
    SysTick_Config(SystemCoreClock / QPBSP::TICKS_PER_SEC);

    // assing all priority bits for preemption-prio. and none to sub-prio.
    NVIC_SetPriorityGrouping(0U);

    // set priorities of ALL ISRs used in the system, see NOTE1
    //
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!! CAUTION !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // Assign a priority to EVERY ISR explicitly by calling NVIC_SetPriority().
    // DO NOT LEAVE THE ISR PRIORITIES AT THE DEFAULT VALUE!
    //
    NVIC_SetPriority(USART1_IRQn,  0U); // kerel unaware interrupt
    //NVIC_SetPriority(GPIO_EVEN_IRQn, QF_AWARE_ISR_CMSIS_PRI);
    NVIC_SetPriority(SysTick_IRQn, QF_AWARE_ISR_CMSIS_PRI + 1U);
    // ...

    // enable IRQs...
    //NVIC_EnableIRQ(GPIO_EVEN_IRQn);
#ifdef Q_SPY
    NVIC_EnableIRQ(USART1_IRQn); // UART1 interrupt used for QS-RX
#endif
}
void QK::onIdle(){
    /*Read user button*/
    QPBSP::readButton();
}
void QP::QF::onCleanup(void) {}
//void QP::QF_onClockTick(void) {
//    QF::TICK_X(0U, 0); // QF clock tick processing for rate 0
//}
void Q_onAssert(char const * const module, int loc) {
    //cerr << "Assertion failed in " <<  module << ":" << loc << endl;
    exit(-1);
}
